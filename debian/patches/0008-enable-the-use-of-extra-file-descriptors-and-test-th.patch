From: Daniel Kahn Gillmor <dkg@fifthhorseman.net>
Date: Fri, 28 Sep 2018 14:46:37 -0400
Subject: enable the use of extra file descriptors, and test them

 * add "infds" and "outfds" to the enigmailprocess_* implementation,
   passing the file descriptors back and forth between the threads as
   needed to permit additional (non-stdin/stdout/stderr) file
   descriptors to be passed to the subprocess.

 * NOTE: this presumably does not work on Windows at all!

 * use infds and outfds within subprocess.jsm
---
 ipc/modules/enigmailprocess_common.jsm     | 42 +++++++++++++++++++++++---
 ipc/modules/enigmailprocess_main.jsm       | 14 +++++++++
 ipc/modules/enigmailprocess_worker_unix.js |  8 +++++
 ipc/modules/subprocess.jsm                 | 48 ++++++++++++++++++++++++++++++
 ipc/tests/subprocess-test.js               | 28 +++++++++++++++++
 5 files changed, 136 insertions(+), 4 deletions(-)

diff --git a/ipc/modules/enigmailprocess_common.jsm b/ipc/modules/enigmailprocess_common.jsm
index 06859c3..4e64a42 100644
--- a/ipc/modules/enigmailprocess_common.jsm
+++ b/ipc/modules/enigmailprocess_common.jsm
@@ -598,12 +598,19 @@ class _BaseProcess {
    *        The internal ID of the Process object, which ties it to the
    *        corresponding process on the Worker side.
    * @param {integer[]} fds
-   *        An array of internal Pipe IDs, one for each standard file descriptor
-   *        in the child process.
+   *        An array of internal Pipe IDs, one for each connected file descriptor
+   *        in the child process.  fds[N] is the parent process's FD that connects
+   *        via a pipe to FD N of the child process
    * @param {integer} pid
    *        The operating system process ID of the process.
+   * @param {integer[]} infds
+   *        list of child processes extra FDs (beyond stdin) that should be input
+   *        from the perspective of the child process.
+   * @param {integer[]} outfds
+   *        list of child processes extra FDs (beyond stdout and stderr) that
+   *        should be output from the perspective of the child process.
    */
-  constructor(worker, processId, fds, pid) {
+  constructor(worker, processId, fds, pid, infds, outfds) {
     this.id = processId;
     this.worker = worker;
 
@@ -626,6 +633,33 @@ class _BaseProcess {
         this.exitCode = exitCode;
       });
     });
+    /**
+     * @property {Map} infds
+     *                 A Map from the child process's input file
+     *                 descriptors to pipes to write to them.  Note
+     *                 that the child's stdin (FD 0) is handled
+     *                 separately (by the property stdin).
+     *                 @readonly
+     */
+    this.infds = new Map();
+    /**
+     * @property {Map} outfds
+     *                 A Map from the child process's output file
+     *                 descriptors to pipes to read from them. Note
+     *                 that stdout and stderr (FDs 1 and 2) are
+     *                 handled separately (by the properties stdout and
+     *                 stderr).
+     *                 @readonly
+     */
+    this.outfds = new Map();
+
+    for (let fd of infds) {
+      this.infds.set(fd, new OutputPipe(this, fd, fds[fd]));
+    }
+
+    for (let fd of outfds) {
+      this.outfds.set(fd, new InputPipe(this, fd, fds[fd]));
+    }
 
     if (fds[0] !== undefined) {
       /**
@@ -670,7 +704,7 @@ class _BaseProcess {
     return worker.call("spawn", [options]).then(({
       processId, fds, pid
     }) => {
-      return new this(worker, processId, fds, pid);
+      return new this(worker, processId, fds, pid, options.infds, options.outfds);
     });
   }
 
diff --git a/ipc/modules/enigmailprocess_main.jsm b/ipc/modules/enigmailprocess_main.jsm
index 266bf14..2012428 100644
--- a/ipc/modules/enigmailprocess_main.jsm
+++ b/ipc/modules/enigmailprocess_main.jsm
@@ -87,6 +87,18 @@ var SubprocessMain = {
    * - `"pipe"`: The process's stderr is redirected to a pipe, which can be read
    *   from via its `stderr` property.
    *
+   * @param {integer[]} [options.infds]
+   *   - a list of file descriptors which should be returned in
+   *     the resulting process object as keys in an "infds" member.
+   *     These file descriptors should be > 3 and should not
+   *     intersect with outfds (see below).
+   *
+   * @param {integer[]} [options.outfds]
+   *   - a list of the file descriptors which should be returned in
+   *     the resulting process object as a keys in an "outfds" member.
+   *     These file descriptors should be > 3 and should not
+   *     intersect with infds (see above).
+   *
    * @param {string} [options.workdir]
    *        The working directory in which to launch the new process.
    *
@@ -109,6 +121,8 @@ var SubprocessMain = {
 
       options.stderr = options.stderr || "ignore";
       options.workdir = options.workdir || null;
+      options.infds = options.infds || [];
+      options.outfds = options.outfds || [];
 
       let environment = {};
       if (!options.environment || options.environmentAppend) {
diff --git a/ipc/modules/enigmailprocess_worker_unix.js b/ipc/modules/enigmailprocess_worker_unix.js
index ebffdc9..ab4a792 100644
--- a/ipc/modules/enigmailprocess_worker_unix.js
+++ b/ipc/modules/enigmailprocess_worker_unix.js
@@ -392,6 +392,14 @@ class Process extends BaseProcess {
     this.fd = our_pipes[3].fd;
     delete our_pipes[3];
 
+    // add additional file descriptors:
+    for (let fd in options.infds) {
+      their_pipes.set(Number(options.infds[fd]), pipe(false, options.infds[fd]));
+    }
+    for (let fd in options.outfds) {
+      their_pipes.set(Number(options.outfds[fd]), pipe(true, options.outfds[fd]));
+    }
+
     this.pipes = our_pipes;
 
     return their_pipes;
diff --git a/ipc/modules/subprocess.jsm b/ipc/modules/subprocess.jsm
index b62c676..d8ea4ab 100644
--- a/ipc/modules/subprocess.jsm
+++ b/ipc/modules/subprocess.jsm
@@ -25,6 +25,14 @@
  *    stderr: function(data) {
  *      dump("got data on stderr:" + data + "\n");
  *    },
+ *    infds: {
+ *       4: "this is an input stream as a simple string"
+ *    },
+ *    outfds: {
+ *      5: function(data) {
+ *        dump("got data on file descriptor 5:" + data + "\n");
+ *      }
+ *    },
  *    done: function(result) {
  *      dump("process terminated with " + result.exitCode + "\n");
  *    },
@@ -71,6 +79,13 @@
  *              something like 'data.replace(/\0/g, "\\0");'.
  *              (on windows it only gets called once right now)
  *
+ * infds:       a dictionary where the keys are file descriptor numbers >3, and
+ *              the values are strings that will be written to the associated FD
+ *              (like string-based stdin, but for extended file descriptors)
+ *
+ * outfds:      a dictionary where the keys are file descriptor numbers >3, and
+ *              the values are functions that accept data as their argument
+ *              (like stdout and stderr, but for extended file descriptors)
  *
  * done:        optional function that is called when the process has terminated.
  *              The exit code from the process available via result.exitCode. If
@@ -231,6 +246,19 @@ var subprocess = {
         });
       }
 
+      for (let fd in options.infds) {
+        if (typeof options.infds[fd] === "string") {
+          DEBUG_LOG("writing to file descriptor " + fd);
+          writePipe(proc.infds.get(fd), options.infds[fd]);
+        } else {
+          let errStr = 'infds[' + fd + '] needs to be a string, not a ' + typeof options.infds[fd];
+          ERROR_LOG(errStr);
+          throw ("subprocess.jsm call(): " + errStr);
+        }
+        Promise.all(inputPromises).then(() => {
+          proc.infds.get(fd).close();
+        });
+      }
 
       promises.push(
         readAllData(proc.stdout, read, data => {
@@ -243,6 +271,18 @@ var subprocess = {
             stdoutData += data;
         }));
 
+      for (let fd in options.outfds) {
+        promises.push(
+          readAllData(proc.outfds.get(fd), read, data => {
+            DEBUG_LOG("Got output FD " + fd + ": " + data.length + "\n");
+            if (typeof options.outfds[fd] === "function") {
+              options.outfds[fd](data);
+            } else {
+              throw new Error("outfds[" + fd + "] needs to be a function, not a " + typeof options.outfds[fd]);
+            }
+          }));
+      }
+
       if (!options.mergeStderr) {
         promises.push(
           readAllData(proc.stderr, read, data => {
@@ -301,6 +341,14 @@ var subprocess = {
       opts.stderr = "pipe";
     }
 
+    if (options.infds) {
+      opts.infds = Object.keys(options.infds);
+    }
+
+    if (options.outfds) {
+      opts.outfds = Object.keys(options.outfds);
+    }
+
     if (options.command instanceof Ci.nsIFile) {
       opts.command = options.command.path;
     } else {
diff --git a/ipc/tests/subprocess-test.js b/ipc/tests/subprocess-test.js
index 5e68b18..5e5f85b 100644
--- a/ipc/tests/subprocess-test.js
+++ b/ipc/tests/subprocess-test.js
@@ -294,6 +294,34 @@ function run_test() {
 
   p.wait();
 
+  /////////////////////////////////////////////////////////////////
+  // Test extra file descriptors
+  /////////////////////////////////////////////////////////////////
+
+  do_print("caesar cipher on FD 4 and FD 5");
+
+  gResultData = "";
+  try {
+    p = subprocess.call({
+      command: pl.path,
+      arguments: [cmd.path, 'caesar', '4', '5'],
+      environment: envList,
+      infds: {4: 'monkey' },
+      outfds: {5: function(data) {
+        gResultData += data;
+      } },
+      done: function(result) {
+        Assert.equal(0, result.exitCode, "exit code");
+        Assert.equal("zbaxrl", gResultData, "transformed data");
+      },
+      mergeStderr: false
+    });
+  } catch (ex) {
+    Assert.ok(false, "error: " + ex);
+  }
+
+  p.wait();
+
 
   /////////////////////////////////////////////////////////////////
   // Test many concurrent runs
