From: Daniel Kahn Gillmor <dkg@fifthhorseman.net>
Date: Thu, 14 Jun 2018 00:54:05 -0400
Subject: drop use of OpenPGP.js for generating minimal keys

This depends on GnuPG features released only in 2.2.9 (see
https://dev.gnupg.org/T4019 and https://dev.gnupg.org/T3804)

Note that keyRing-test.js now exports old-style packets again.

In 32ec9c3b81d6bd38112af721af23b65ba3159e63 the test suite was
modified to account for emitting new-style packets for the primary
public key (apparently that's what OpenPGP.js does).  GnuPG emits
old-style packets where the packet tag < 16 for maximal
interoperability.  OpenPGP.js apparently uses new format packet
headers instead.

see:  https://tools.ietf.org/html/rfc4880#section-4.2

We choose to emit signing-capable subkeys as well as
encryption-capable subkeys, even though it's not strictly required by
the Autocrypt spec.

We also change to ensuring that we select the minimal key per e-mail
address, not just a generic minimal key.
---
 package/keyRing.jsm | 124 +++-------------------------------------------------
 1 file changed, 5 insertions(+), 119 deletions(-)

diff --git a/package/keyRing.jsm b/package/keyRing.jsm
index f3a1ae8..ac2f759 100644
--- a/package/keyRing.jsm
+++ b/package/keyRing.jsm
@@ -2267,18 +2267,13 @@ KeyObject.prototype = {
     };
 
 
-    // TODO: remove ECC special case once OpenPGP.js supports it
-    let isECC = (this.algoSym.search(/(ECDH|ECDSA|EDDSA)/) >= 0);
-
     if (!this.minimalKeyBlock[emailAddress]) {
       let args = EnigmailGpg.getStandardArgs(true);
 
-      if (!isECC) {
-        args = args.concat(["--export-options", "export-minimal,no-export-attributes", "-a", "--export", this.fpr]);
-      }
-      else {
-        args = args.concat(["--export-options", "export-minimal,no-export-attributes", "--export", this.fpr]);
-      }
+      args = args.concat(["--export-options", "export-minimal,no-export-attributes",
+                          "--export-filter", "keep-uid=mbox="+emailAddress,
+                          "--export-filter", "drop-subkey=usage!~e && usage!~s",
+                          "--export", this.fpr]);
 
       const statusObj = {};
       const exitCodeObj = {};
@@ -2304,17 +2299,7 @@ KeyObject.prototype = {
       }
 
       if (exportOK) {
-        this.minimalKeyBlock[emailAddress] = null;
-
-        if (isECC) {
-          this.minimalKeyBlock[emailAddress] = btoa(keyBlock);
-        }
-        else {
-          let minKey = getStrippedKey(keyBlock, emailAddress);
-          if (minKey) {
-            this.minimalKeyBlock[emailAddress] = btoa(String.fromCharCode.apply(null, minKey));
-          }
-        }
+        this.minimalKeyBlock[emailAddress] = btoa(keyBlock);
 
         if (!this.minimalKeyBlock[emailAddress]) {
           retObj.exitCode = 1;
@@ -2350,103 +2335,4 @@ KeyObject.prototype = {
   }
 };
 
-
-function _getBestUserId(key, emailAddress) {
-  let bestUser = [];
-  for (let i = 0; i < key.users.length; i++) {
-    if (!key.users[i].userId || !key.users[i].selfCertifications) {
-      continue;
-    }
-    for (let j = 0; j < key.users[i].selfCertifications.length; j++) {
-      bestUser.push({
-        user: key.users[i],
-        selfCertificate: key.users[i].selfCertifications[j]
-      });
-    }
-  }
-  /* prefer matching e-mail addresses, then primary user IDs,
-     then most-recent signatures: */
-  bestUser = bestUser.sort(function(a, b) {
-    if ((a.user.userId.userid == emailAddress ||
-      a.user.userId.userid.endsWith(' <' + emailAddress + '>')) &&
-      !(b.user.userId.userid == emailAddress ||
-      b.user.userId.userid.endsWith(' <' + emailAddress + '>'))) {
-      return -1;
-    }
-    else if ((b.user.userId.userid == emailAddress ||
-      b.user.userId.userid.endsWith(' <' + emailAddress + '>')) &&
-      !(a.user.userId.userid == emailAddress ||
-      a.user.userId.userid.endsWith(' <' + emailAddress + '>'))) {
-      return 1;
-    }
-    else if (a.selfCertificate.isPrimaryUserID > b.selfCertificate.isPrimaryUserID) {
-      return -1;
-    }
-    else if (a.selfCertificate.isPrimaryUserID < b.selfCertificate.isPrimaryUserID) {
-      return 1;
-    }
-    else if (a.selfCertificate.created > b.selfCertificate.created) {
-      return -1;
-    }
-    else if (a.selfCertificate.created < b.selfCertificate.created) {
-      return 1;
-    }
-    else {
-      return 0;
-    }
-  });
-  /* return first valid certification: */
-  for (var k = 0; k < bestUser.length; k++) {
-    if (bestUser[k].user.isValidSelfCertificate(key.primaryKey, bestUser[k].selfCertificate)) {
-      return bestUser[k];
-    }
-  }
-  return null;
-}
-
-/**
- * Get a minimal stripped key containing only:
- * - The public key
- * - the matching UID (or primary UID, if no match) + its self-signature
- * - any valid signing-capable or encryption-capable subkeys + their signature packets
- *
- * @param armoredKey - String: Key data (in OpenPGP armored format)
- * @param emailAddress - String: e-mail address that we want to match a user ID to
- *
- * @return Uint8Array, or null
- */
-
-function getStrippedKey(armoredKey, emailAddress) {
-  EnigmailLog.DEBUG("keyRing.jsm: KeyObject.getStrippedKey()\n");
-
-  try {
-    let openpgp = getOpenPGP().openpgp;
-    let msg = openpgp.key.readArmored(armoredKey);
-
-    if (!msg || msg.keys.length === 0) return null;
-
-    let key = msg.keys[0];
-    let uid = _getBestUserId(key, emailAddress);
-    if (!uid || !uid.user) return null;
-
-    let p = new openpgp.packet.List();
-    p.push(key.primaryKey);
-    p.concat(uid.user.toPacketlist());
-
-    // go through the subkeys and pull out only valid encryption-capable and
-    // signing-capable subkeys.
-    for (let i = 0; i < key.subKeys.length; i++) {
-      if (key.subKeys[i].isValidEncryptionKey(key.primaryKey) ||
-        key.subKeys[i].isValidSigningKey(key.primaryKey)) {
-        p.concat(key.subKeys[i].toPacketlist());
-      }
-    }
-
-    return p.write();
-  } catch (ex) {
-    EnigmailLog.DEBUG("keyRing.jsm: KeyObject.getStrippedKey: ERROR " + ex.message + "\n");
-  }
-  return null;
-}
-
 EnigmailKeyRing.clearCache();
