From: Daniel Kahn Gillmor <dkg@fifthhorseman.net>
Date: Thu, 14 Jun 2018 00:00:41 -0400
Subject: avoid OpenPGP.js during key file import

note that the revocation certificate import handling is still
contingent on GnuPG's mechanisms for reporting standalone revocation
certs:

https://dev.gnupg.org/T4018

This means we depend on a more recent version (or a patched version)
of GnuPG than upstream enigmail does.
---
 package/key.jsm | 58 ++-------------------------------------------------------
 1 file changed, 2 insertions(+), 56 deletions(-)

diff --git a/package/key.jsm b/package/key.jsm
index 0b4a0ef..565273f 100644
--- a/package/key.jsm
+++ b/package/key.jsm
@@ -137,7 +137,8 @@ var EnigmailKey = {
    *          - id (key ID)
    *          - fpr
    *          - name (the UID of the key)
-   *          - state (one of "old" [existing key], "new" [new key], "invalid" [key cannot not be imported])
+   *          - isSecret (boolean)
+   *          - revoke? (boolean, true if contains a revocation cert, undefined is the same as false)
    */
   getKeyListFromKeyBlock: function(keyBlockStr, errorMsgObj, interactive = true) {
     EnigmailLog.DEBUG("key.jsm: getKeyListFromKeyBlock()\n");
@@ -150,61 +151,6 @@ var EnigmailKey = {
     let keyList = getGpgKeyData(keyBlockStr);
     let key = {};
 
-    if (keyList.length === 0) {
-      EnigmailLog.DEBUG("key.jsm: getKeyListFromKeyBlock: no data from GnuPG\n");
-      if (keyBlockStr.search(/-----BEGIN PGP (PUBLIC|PRIVATE) KEY BLOCK-----/) >= 0) {
-        blocks = this.splitArmoredBlocks(keyBlockStr);
-      } else {
-        isBinary = true;
-        blocks = [EnigmailOpenPGP.enigmailFuncs.bytesToArmor(EnigmailOpenPGP.openpgp.enums.armor.public_key, keyBlockStr)];
-      }
-
-      for (let b of blocks) {
-        let m = EnigmailOpenPGP.openpgp.message.readArmored(b);
-
-        for (let i = 0; i < m.packets.length; i++) {
-          let packetType = EnigmailOpenPGP.openpgp.enums.read(EnigmailOpenPGP.openpgp.enums.packet, m.packets[i].tag);
-          switch (packetType) {
-            case "publicKey":
-            case "secretKey":
-              key = {
-                id: m.packets[i].getKeyId().toHex().toUpperCase(),
-                fpr: m.packets[i].getFingerprint().toUpperCase(),
-                name: null,
-                isSecret: false
-              };
-
-              if (!(key.id in keyList)) {
-                keyList[key.id] = key;
-              }
-
-              if (packetType === "secretKey") {
-                keyList[key.id].isSecret = true;
-              }
-              break;
-            case "userid":
-              if (!key.name) {
-                key.name = m.packets[i].userid.replace(/[\r\n]+/g, " ");
-              }
-              break;
-            case "signature":
-              if (m.packets[i].signatureType === SIG_TYPE_REVOCATION) {
-                let keyId = m.packets[i].issuerKeyId.toHex().toUpperCase();
-                if (keyId in keyList) {
-                  keyList[keyId].revoke = true;
-                } else {
-                  keyList[keyId] = {
-                    revoke: true,
-                    id: keyId
-                  };
-                }
-              }
-              break;
-          }
-        }
-      }
-    }
-
     let retArr = [];
     for (let k in keyList) {
       retArr.push(keyList[k]);
