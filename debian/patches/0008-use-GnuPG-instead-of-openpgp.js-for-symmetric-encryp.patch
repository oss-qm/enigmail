From: Daniel Kahn Gillmor <dkg@fifthhorseman.net>
Date: Sun, 30 Sep 2018 01:54:12 -0500
Subject: use GnuPG instead of openpgp.js for symmetric encryption/decryption

This enables all the test suite to pass, and should enable proper use
of the Autocrypt setup message.

We need to handle PLAINTEXT status lines that include a possible
filename in them.  And sometimes GnuPG gets confused about the
different sizes of plaintext: https://dev.gnupg.org/T4741.  so just
warn, don't throw an exception for now as a workaround.
---
 package/autocrypt.jsm |  92 ++++++++++++++---------------
 package/gpg.jsm       | 156 +++++++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 201 insertions(+), 47 deletions(-)

diff --git a/package/autocrypt.jsm b/package/autocrypt.jsm
index d04cd4f..74c7de5 100644
--- a/package/autocrypt.jsm
+++ b/package/autocrypt.jsm
@@ -11,8 +11,6 @@
 
 var EXPORTED_SYMBOLS = ["EnigmailAutocrypt"];
 
-const Cr = Components.results;
-
 Components.utils.importGlobalProperties(["crypto"]);
 
 const jsmime = ChromeUtils.import("resource:///modules/jsmime.jsm").jsmime;
@@ -38,6 +36,7 @@ const EnigmailStdlib = ChromeUtils.import("chrome://enigmail/content/modules/std
 const EnigmailPrefs = ChromeUtils.import("chrome://enigmail/content/modules/prefs.jsm").EnigmailPrefs;
 const EnigmailConstants = ChromeUtils.import("chrome://enigmail/content/modules/constants.jsm").EnigmailConstants;
 const EnigmailCryptoAPI = ChromeUtils.import("chrome://enigmail/content/modules/cryptoAPI.jsm").EnigmailCryptoAPI;
+const EnigmailGpg = ChromeUtils.import("chrome://enigmail/content/modules/gpg.jsm").EnigmailGpg;
 
 var gCreatedSetupIds = [];
 
@@ -470,14 +469,15 @@ var EnigmailAutocrypt = {
 
         let bkpCode = createBackupCode();
         let enc = {
-          message: EnigmailOpenPGP.openpgp.message.fromText(innerMsg),
-          passwords: bkpCode,
+          message: innerMsg,
+          password: bkpCode,
           armor: true
         };
 
         // create symmetrically encrypted message
-        EnigmailOpenPGP.openpgp.encrypt(enc).then(msg => {
-          let msgData = EnigmailArmor.replaceArmorHeaders(msg.data, {
+        try {
+          let msg = EnigmailGpg.symmetricEncrypt(enc);
+          let msgData = EnigmailArmor.replaceArmorHeaders(msg, {
             'Passphrase-Format': 'numeric9x4',
             'Passphrase-Begin': bkpCode.substr(0, 2)
           }).replace(/\n/g, "\r\n");
@@ -487,10 +487,10 @@ var EnigmailAutocrypt = {
             msg: m,
             passwd: bkpCode
           });
-        }).catch(e => {
+        } catch(e) {
           EnigmailLog.DEBUG("autocrypt.jsm: createSetupMessage: error " + e + "\n");
           reject(2);
-        });
+        }
       }
       catch (ex) {
         EnigmailLog.DEBUG("autocrypt.jsm: createSetupMessage: error " + ex.toString() + "\n");
@@ -598,46 +598,46 @@ var EnigmailAutocrypt = {
         end = {};
       let msgType = EnigmailArmor.locateArmoredBlock(attachmentData, 0, "", start, end, {});
 
-      EnigmailOpenPGP.openpgp.message.readArmored(attachmentData.substring(start.value, end.value)).then(encMessage => {
-          let enc = {
-            message: encMessage,
-            passwords: [passwd],
-            format: 'utf8'
-          };
+      let encMessage = attachmentData.substring(start.value, end.value);
 
-          return EnigmailOpenPGP.openpgp.decrypt(enc);
-        })
-        .then(msg => {
-          EnigmailLog.DEBUG("autocrypt.jsm: handleBackupMessage: data: " + msg.data.length + "\n");
-
-          let setupData = importSetupKey(msg.data);
-          if (setupData) {
-            EnigmailKeyEditor.setKeyTrust(null, "0x" + setupData.fpr, "5", function(returnCode) {
-              if (returnCode === 0) {
-                let id = EnigmailStdlib.getIdentityForEmail(EnigmailFuncs.stripEmail(fromAddr).toLowerCase());
-                let ac = EnigmailFuncs.getAccountForIdentity(id.identity);
-                ac.incomingServer.setBoolValue("enableAutocrypt", true);
-                ac.incomingServer.setIntValue("acPreferEncrypt", (setupData.preferEncrypt === "mutual" ? 1 : 0));
-                id.identity.setCharAttribute("pgpkeyId", "0x" + setupData.fpr);
-                id.identity.setBoolAttribute("enablePgp", true);
-                id.identity.setBoolAttribute("pgpSignEncrypted", true);
-                id.identity.setBoolAttribute("pgpMimeMode", true);
-                id.identity.setIntAttribute("pgpKeyMode", 1);
-                EnigmailPrefs.setPref("juniorMode", 1);
-                resolve(setupData);
-              }
-              else {
-                reject("keyImportFailed");
-              }
-            });
-          }
-          else {
-            reject("keyImportFailed");
-          }
-        }).
-      catch(err => {
+      let enc = {
+        message: encMessage,
+        password: passwd,
+        format: 'utf8'
+      };
+
+      try {
+        let msg = EnigmailGpg.symmetricDecrypt(enc);
+
+        EnigmailLog.DEBUG("autocrypt.jsm: handleBackupMessage: data: " + msg.length + "\n");
+
+        let setupData = importSetupKey(msg);
+        if (setupData) {
+          EnigmailKeyEditor.setKeyTrust(null, "0x" + setupData.fpr, "5", function(returnCode) {
+            if (returnCode === 0) {
+              let id = EnigmailStdlib.getIdentityForEmail(EnigmailFuncs.stripEmail(fromAddr).toLowerCase());
+              let ac = EnigmailFuncs.getAccountForIdentity(id.identity);
+              ac.incomingServer.setBoolValue("enableAutocrypt", true);
+              ac.incomingServer.setIntValue("acPreferEncrypt", (setupData.preferEncrypt === "mutual" ? 1 : 0));
+              id.identity.setCharAttribute("pgpkeyId", "0x" + setupData.fpr);
+              id.identity.setBoolAttribute("enablePgp", true);
+              id.identity.setBoolAttribute("pgpSignEncrypted", true);
+              id.identity.setBoolAttribute("pgpMimeMode", true);
+              id.identity.setIntAttribute("pgpKeyMode", 1);
+              EnigmailPrefs.setPref("juniorMode", 1);
+              resolve(setupData);
+            }
+            else {
+              reject("keyImportFailed");
+            }
+          });
+        }
+        else {
+          reject("keyImportFailed");
+        }
+      } catch(err) {
         reject("wrongPasswd");
-      });
+      }
     });
   },
 
diff --git a/package/gpg.jsm b/package/gpg.jsm
index 70465bf..489b1cd 100644
--- a/package/gpg.jsm
+++ b/package/gpg.jsm
@@ -382,10 +382,164 @@ var EnigmailGpg = {
     }
   },
 
+  symmetricEncrypt: function(params) {
+    EnigmailLog.DEBUG("gpg.jsm: symmetricEncrypt:\n");
+
+    const args = EnigmailGpg.getStandardArgs(false).
+          concat(['--no-options',
+                  '--no-keyring',
+                  '--no-symkey-cache',
+                  '--cipher-algo=aes256',
+                  '--pinentry-mode=loopback',
+                  '--passphrase-fd=4',
+                  '--status-fd=5',
+                  '--symmetric']);
+    if (params.armor)
+      args.push('--armor');
+
+    try {
+      let statusdata = '';
+      let ciphertext;
+      let warnings = [];
+      const proc = subprocess.call({
+        command: EnigmailGpg.agentPath,
+        arguments: args,
+        environment: EnigmailCore.getEnvList(),
+        charset: null,
+        stdin: params.message,
+        infds: { 4: params.password },
+        outfds: {
+          5: function(data) {
+            statusdata += data;
+          }
+        },
+        mergeStderr: false,
+        done: function(result) {
+          if (result.exitCode != 0) {
+            warnings.unshift("non-zero return code! " + result.exitCode);
+            return;
+          }
+          if (statusdata.match(/\[GNUPG:\] NEED_PASSPHRASE_SYM \d+ \d+ \d+\n\[GNUPG:\] BEGIN_ENCRYPTION \d+ \d+\n\[GNUPG:\] END_ENCRYPTION\n/) === null) {
+            warnings.unshift("status return was unexpected: " + statusdata);
+            return;
+          }
+          ciphertext = result.stdout;
+        }
+      });
+      proc.wait();
+      if (warnings.length) {
+        for (let ix in warnings) {
+          /* we display the warnings here because it's not clear to
+           * dkg that the "done" function is running from a thread
+           * capable of executing them correctly. */
+          EnigmailLog.WARNING(warnings[ix]+"\n");
+        }
+      }
+      if (ciphertext == undefined)
+        EnigmailLog.WARNING("ciphertext output was never received\n");
+      return ciphertext;
+    }
+    catch (ex) {
+      EnigmailLog.ERROR("enigmailCommon.jsm: encryptSymmetric: subprocess.call failed with '" + ex.toString() + "'\n");
+      throw ex;
+    }
+  },
+
+  /* params contains fields: message (string), password (string), and format (string).
+   */
+  symmetricDecrypt: function(params) {
+    EnigmailLog.DEBUG("gpg.jsm: symmetricDecrypt:\n");
+
+    const args = EnigmailGpg.getStandardArgs(false).
+          concat(['--no-options',
+                  '--no-keyring',
+                  '--no-symkey-cache',
+                  '--pinentry-mode=loopback',
+                  '--passphrase-fd=4',
+                  '--status-fd=5',
+                  '--decrypt']);
+    /*  FIXME: format is going to be 'utf8' -- what does that mean, and
+     *  how do we apply it to GnuPG? */
+
+    try {
+      let statusdata = '';
+      let cleartext;
+      let warnings = [];
+      const proc = subprocess.call({
+        command: EnigmailGpg.agentPath,
+        arguments: args,
+        environment: EnigmailCore.getEnvList(),
+        charset: null,
+        stdin: params.message,
+        infds: { 4: params.password },
+        outfds: {
+          5: function(data) {
+            statusdata += data;
+          }
+        },
+        mergeStderr: false,
+        done: function(result) {
+          if (result.exitCode != 0) {
+            warnings.unshift("non-zero return code when decrypting! " + result.exitCode);
+            return;
+          }
+
+          let decrypt_status_re = /\[GNUPG:\] NEED_PASSPHRASE_SYM \d+ \d+ \d+\n\[GNUPG:] BEGIN_DECRYPTION\n(\[GNUPG:\] DECRYPTION_COMPLIANCE_MODE \d+\n)?\[GNUPG:\] DECRYPTION_INFO \d+ \d+\n\[GNUPG:\] PLAINTEXT \d+ \d+[^\n]*\n(\[GNUPG:\] PLAINTEXT_LENGTH (\d+)\n)?\[GNUPG:\] DECRYPTION_OKAY\n(\[GNUPG:\] GOODMDC\n)?\[GNUPG:\] END_DECRYPTION\n/m
+          let matched = false;
+          let found = decrypt_status_re.exec(statusdata);
+          if (found !== null) {
+            let all = found[0];
+            let compliance = found[1];
+            let plen_line = found[2];
+            let plen = found[3];
+            let mdc = found[4];
+            if (all != statusdata)
+              warnings.unshift("Got GnuPG status lines: " + statusdata + "Only matched GnuPG status lines: " + all);
+            /* PLAINTEXT_LENGTH does not necessarily match exactly:
+             * see https://dev.gnupg.org/T4741.  Instead, we assume
+             * that the length could be halved (nothing but CRLFs,
+             * generated on Windows, read on unix) or doubled (nothing
+             * but LFs on unix, read on Windows) at most.*/
+            if (plen_line)
+              if ((result.stdout.length > plen*2) ||
+                  (result.stdout.length < plen/2))
+                warnings.unshift("Status line claimed " + plen + "bytes, but we got " + result.stdout.length);
+            if (mdc != "[GNUPG:] GOODMDC\n") {
+              warnings.unshift("No MDC used in encryption, skipping decryption");
+              return;
+            }
+            matched = true;
+          }
+          if (!matched) {
+            warnings.unshift("Status FDs did not match!");
+            return;
+          }
+          cleartext = result.stdout;
+        }
+      });
+      proc.wait();
+      if (warnings.length) {
+        for (let ix in warnings) {
+          /* we display the warnings here because it's not clear to
+           * dkg that the "done" function is running from a thread
+           * capable of executing them correctly. */
+          EnigmailLog.WARNING(warnings[ix]+"\n");
+        }
+      }
+      if (cleartext == undefined)
+        EnigmailLog.WARNING("cleartext output was never received\n");
+      return cleartext;
+    }
+    catch (ex) {
+      EnigmailLog.ERROR("enigmailCommon.jsm: decryptSymmetric: subprocess.call failed with '" + ex.toString() + "'\n");
+      throw ex;
+    }
+  },
+
   /**
    * For versions of GPG 2.1 and higher, checks to see if the dirmngr is configured to use Tor
    *
    * @return    Boolean     - True if dirmngr is configured with Tor. False otherwise
    */
   dirmngrConfiguredWithTor: dirmngrConfiguredWithTor
-};
\ No newline at end of file
+};
