From: Daniel Kahn Gillmor <dkg@fifthhorseman.net>
Date: Sun, 30 Sep 2018 01:54:12 -0500
Subject: use GnuPG instead of openpgp.js for symmetric encryption/decryption

This enables all the test suite to pass, and should enable proper use
of the Autocrypt setup message.
---
 package/autocrypt.jsm |  86 +++++++++++++++++++--------------------
 package/gpg.jsm       | 110 ++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 153 insertions(+), 43 deletions(-)

diff --git a/package/autocrypt.jsm b/package/autocrypt.jsm
index d04cd4f..0febd8f 100644
--- a/package/autocrypt.jsm
+++ b/package/autocrypt.jsm
@@ -11,8 +11,6 @@
 
 var EXPORTED_SYMBOLS = ["EnigmailAutocrypt"];
 
-const Cr = Components.results;
-
 Components.utils.importGlobalProperties(["crypto"]);
 
 const jsmime = ChromeUtils.import("resource:///modules/jsmime.jsm").jsmime;
@@ -38,6 +36,7 @@ const EnigmailStdlib = ChromeUtils.import("chrome://enigmail/content/modules/std
 const EnigmailPrefs = ChromeUtils.import("chrome://enigmail/content/modules/prefs.jsm").EnigmailPrefs;
 const EnigmailConstants = ChromeUtils.import("chrome://enigmail/content/modules/constants.jsm").EnigmailConstants;
 const EnigmailCryptoAPI = ChromeUtils.import("chrome://enigmail/content/modules/cryptoAPI.jsm").EnigmailCryptoAPI;
+const EnigmailGpg = ChromeUtils.import("chrome://enigmail/content/modules/gpg.jsm").EnigmailGpg;
 
 var gCreatedSetupIds = [];
 
@@ -476,7 +475,8 @@ var EnigmailAutocrypt = {
         };
 
         // create symmetrically encrypted message
-        EnigmailOpenPGP.openpgp.encrypt(enc).then(msg => {
+        try {
+          let msg = EnigmailGpg.symmetricEncrypt(enc);
           let msgData = EnigmailArmor.replaceArmorHeaders(msg.data, {
             'Passphrase-Format': 'numeric9x4',
             'Passphrase-Begin': bkpCode.substr(0, 2)
@@ -487,10 +487,10 @@ var EnigmailAutocrypt = {
             msg: m,
             passwd: bkpCode
           });
-        }).catch(e => {
+        } catch(e) {
           EnigmailLog.DEBUG("autocrypt.jsm: createSetupMessage: error " + e + "\n");
           reject(2);
-        });
+        }
       }
       catch (ex) {
         EnigmailLog.DEBUG("autocrypt.jsm: createSetupMessage: error " + ex.toString() + "\n");
@@ -598,46 +598,46 @@ var EnigmailAutocrypt = {
         end = {};
       let msgType = EnigmailArmor.locateArmoredBlock(attachmentData, 0, "", start, end, {});
 
-      EnigmailOpenPGP.openpgp.message.readArmored(attachmentData.substring(start.value, end.value)).then(encMessage => {
-          let enc = {
-            message: encMessage,
-            passwords: [passwd],
-            format: 'utf8'
-          };
+      let encMessage = attachmentData.substring(start.value, end.value);
 
-          return EnigmailOpenPGP.openpgp.decrypt(enc);
-        })
-        .then(msg => {
-          EnigmailLog.DEBUG("autocrypt.jsm: handleBackupMessage: data: " + msg.data.length + "\n");
-
-          let setupData = importSetupKey(msg.data);
-          if (setupData) {
-            EnigmailKeyEditor.setKeyTrust(null, "0x" + setupData.fpr, "5", function(returnCode) {
-              if (returnCode === 0) {
-                let id = EnigmailStdlib.getIdentityForEmail(EnigmailFuncs.stripEmail(fromAddr).toLowerCase());
-                let ac = EnigmailFuncs.getAccountForIdentity(id.identity);
-                ac.incomingServer.setBoolValue("enableAutocrypt", true);
-                ac.incomingServer.setIntValue("acPreferEncrypt", (setupData.preferEncrypt === "mutual" ? 1 : 0));
-                id.identity.setCharAttribute("pgpkeyId", "0x" + setupData.fpr);
-                id.identity.setBoolAttribute("enablePgp", true);
-                id.identity.setBoolAttribute("pgpSignEncrypted", true);
-                id.identity.setBoolAttribute("pgpMimeMode", true);
-                id.identity.setIntAttribute("pgpKeyMode", 1);
-                EnigmailPrefs.setPref("juniorMode", 1);
-                resolve(setupData);
-              }
-              else {
-                reject("keyImportFailed");
-              }
-            });
-          }
-          else {
-            reject("keyImportFailed");
-          }
-        }).
-      catch(err => {
+      let enc = {
+        message: encMessage,
+        passwords: [passwd],
+        format: 'utf8'
+      };
+
+      try {
+        let msg = EnigmailGpg.symmetricDecrypt(enc);
+
+        EnigmailLog.DEBUG("autocrypt.jsm: handleBackupMessage: data: " + msg.length + "\n");
+
+        let setupData = importSetupKey(msg.data);
+        if (setupData) {
+          EnigmailKeyEditor.setKeyTrust(null, "0x" + setupData.fpr, "5", function(returnCode) {
+            if (returnCode === 0) {
+              let id = EnigmailStdlib.getIdentityForEmail(EnigmailFuncs.stripEmail(fromAddr).toLowerCase());
+              let ac = EnigmailFuncs.getAccountForIdentity(id.identity);
+              ac.incomingServer.setBoolValue("enableAutocrypt", true);
+              ac.incomingServer.setIntValue("acPreferEncrypt", (setupData.preferEncrypt === "mutual" ? 1 : 0));
+              id.identity.setCharAttribute("pgpkeyId", "0x" + setupData.fpr);
+              id.identity.setBoolAttribute("enablePgp", true);
+              id.identity.setBoolAttribute("pgpSignEncrypted", true);
+              id.identity.setBoolAttribute("pgpMimeMode", true);
+              id.identity.setIntAttribute("pgpKeyMode", 1);
+              EnigmailPrefs.setPref("juniorMode", 1);
+              resolve(setupData);
+            }
+            else {
+              reject("keyImportFailed");
+            }
+          });
+        }
+        else {
+          reject("keyImportFailed");
+        }
+      } catch(err) {
         reject("wrongPasswd");
-      });
+      }
     });
   },
 
diff --git a/package/gpg.jsm b/package/gpg.jsm
index 70465bf..3ce1434 100644
--- a/package/gpg.jsm
+++ b/package/gpg.jsm
@@ -382,6 +382,116 @@ var EnigmailGpg = {
     }
   },
 
+  symmetricEncrypt: function(params) {
+    EnigmailLog.DEBUG("gpg.jsm: symmetricEncrypt:\n");
+
+    const args = EnigmailGpg.getStandardArgs(false).
+          concat(['--no-options',
+                  '--no-keyring',
+                  '--no-symkey-cache',
+                  '--cipher-algo=aes256',
+                  '--pinentry-mode=loopback',
+                  '--passphrase-fd=4',
+                  '--status-fd=5',
+                  '--symmetric']);
+    if (params.armor)
+      args.push('--armor');
+
+    try {
+      let statusdata = '';
+      let ciphertext;
+      const proc = subprocess.call({
+        command: EnigmailGpg.agentPath,
+        arguments: args,
+        environment: EnigmailCore.getEnvList(),
+        charset: null,
+        stdin: params.data,
+        infds: { 4: params.passwords },
+        outfds: {
+          5: function(data) {
+            statusdata += data;
+          }
+        },
+        mergeStderr: false,
+        done: function(result) {
+          if (result.exitCode != 0)
+            throw "non-zero return code! " + result.exitCode;
+          if (statusdata.match(/\[GNUPG:\] NEED_PASSPHRASE_SYM \d+ \d+ \d+\n\[GNUPG:\] BEGIN_ENCRYPTION \d+ \d+\n\[GNUPG:\] END_ENCRYPTION\n/) === null)
+            throw "status return was unexpected: " + statusdata;
+          ciphertext = result.stdout;
+        }
+      });
+      proc.wait();
+      return ciphertext;
+    }
+    catch (ex) {
+      EnigmailLog.ERROR("enigmailCommon.jsm: encryptSymmetric: subprocess.call failed with '" + ex.toString() + "'\n");
+      throw ex;
+    }
+  },
+
+  /* params contains fields: message (string), password (string), and format (string).
+   */
+  symmetricDecrypt: function(params) {
+    EnigmailLog.DEBUG("gpg.jsm: symmetricDecrypt:\n");
+
+    const args = EnigmailGpg.getStandardArgs(false).
+          concat(['--no-options',
+                  '--no-keyring',
+                  '--no-symkey-cache',
+                  '--pinentry-mode=loopback',
+                  '--passphrase-fd=4',
+                  '--status-fd=5',
+                  '--decrypt']);
+    /*  FIXME: format is going to be 'utf8' -- what does that mean, and
+     *  how do we apply it to GnuPG? */
+
+    try {
+      let statusdata = '';
+      let cleartext;
+      const proc = subprocess.call({
+        command: EnigmailGpg.agentPath,
+        arguments: args,
+        environment: EnigmailCore.getEnvList(),
+        charset: null,
+        stdin: params.message,
+        infds: { 4: params.password },
+        outfds: {
+          5: function(data) {
+            statusdata += data;
+          }
+        },
+        mergeStderr: false,
+        done: function(result) {
+          if (result.exitCode != 0)
+            throw "non-zero return code when decrypting! " + result.exitCode;
+
+          let decrypt_status_re = /\[GNUPG:\] NEED_PASSPHRASE_SYM \d+ \d+ \d+\n\[GNUPG:] BEGIN_DECRYPTION\n(\[GNUPG:\] DECRYPTION_COMPLIANCE_MODE \d+\n)?\[GNUPG:\] DECRYPTION_INFO \d+ \d+\n\[GNUPG:\] PLAINTEXT \d+ \d+ *\n(\[GNUPG:\] PLAINTEXT_LENGTH (\d+)\n)?\[GNUPG:\] DECRYPTION_OKAY\n(\[GNUPG:\] GOODMDC\n)?\[GNUPG:\] END_DECRYPTION\n/m
+          let matched = false;
+          statusdata.replace(decrypt_status_re, function(all, compliance, plen_line, plen, mdc) {
+            if (all != statusdata)
+              throw "Got GnuPG status lines: " + statusdata + "Only matched GnuPG status lines: " + all;
+            if (plen_line)
+              if (result.stdout.length != plen)
+                throw "Status line claimed " + plen + "bytes, but we got " + result.stdout.length;
+            if (mdc != "[GNUPG:] GOODMDC\n")
+              throw "No MDC used in encryption";
+            matched = true;
+          });
+          if (!matched)
+            throw "Status FDs did not match!";
+          cleartext = result.stdout;
+        }
+      });
+      proc.wait();
+      return cleartext;
+    }
+    catch (ex) {
+      EnigmailLog.ERROR("enigmailCommon.jsm: decryptSymmetric: subprocess.call failed with '" + ex.toString() + "'\n");
+      throw ex;
+    }
+  },
+
   /**
    * For versions of GPG 2.1 and higher, checks to see if the dirmngr is configured to use Tor
    *
