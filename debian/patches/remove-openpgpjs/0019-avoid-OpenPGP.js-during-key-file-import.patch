From: Daniel Kahn Gillmor <dkg@fifthhorseman.net>
Date: Thu, 14 Jun 2018 00:00:41 -0400
Subject: avoid OpenPGP.js during key file import

note that the revocation certificate import handling is still
contingent on GnuPG's mechanisms for reporting standalone revocation
certs:

https://dev.gnupg.org/T4018
---
 package/key.jsm | 92 +++++++++++++++++++++++++++++++++++----------------------
 1 file changed, 57 insertions(+), 35 deletions(-)

diff --git a/package/key.jsm b/package/key.jsm
index deb1675..778b71f 100644
--- a/package/key.jsm
+++ b/package/key.jsm
@@ -128,7 +128,8 @@ var EnigmailKey = {
    *          - id (key ID)
    *          - fpr
    *          - name (the UID of the key)
-   *          - state (one of "old" [existing key], "new" [new key], "invalid" [key cannot not be imported])
+   *          - isSecret (boolean)
+   *          - revoke? (boolean, true if contains a revocation cert, undefined is the same as false)
    */
   getKeyListFromKeyBlock: function(keyBlockStr, errorMsgObj, interactive = true) {
     EnigmailLog.DEBUG("key.jsm: getKeyListFromKeyBlock\n");
@@ -148,46 +149,67 @@ var EnigmailKey = {
 
     let keyList = [];
     let key = {};
-    for (let b of blocks) {
-      let m = EnigmailOpenPGP.openpgp.message.readArmored(b);
-
-      for (let i = 0; i < m.packets.length; i++) {
-        let packetType = EnigmailOpenPGP.openpgp.enums.read(EnigmailOpenPGP.openpgp.enums.packet, m.packets[i].tag);
-        switch (packetType) {
-          case "publicKey":
-          case "secretKey":
-            key = {
-              id: m.packets[i].getKeyId().toHex().toUpperCase(),
-              fpr: m.packets[i].getFingerprint().toUpperCase(),
-              name: null,
-              isSecret: false
-            };
-
-            if (!(key.id in keyList)) {
-              keyList[key.id] = key;
+      for (let b of blocks) {
+        let args = EnigmailGpg.getStandardArgs(true).concat(["--no-verbose", "--with-colons", "--dry-run", "--import-options", "import-show", "--import"]);
+        const exitCodeObj = {};
+        const statusMsgObj = {};
+        const errorMsgObj = {};
+
+        let packetStr = EnigmailExecution.execCmd(EnigmailGpg.agentPath, args, b, exitCodeObj, {}, statusMsgObj, errorMsgObj);
+        let packetArr = packetStr.split("\n");
+
+        let keyId = null;
+        for (let i = 0; i < packetArr.length; i++) {
+          let packetDetails = packetArr[i].split(":");
+          switch (packetDetails[0]) {
+          case "pub":
+          case "sec":
+            keyId = packetDetails[4].toUpperCase();
+
+            if (!(keyId in keyList)) {
+              keyList[keyId] = {
+                id: keyId,
+                fpr: null,
+                name: null,
+                isSecret: false
+              };
+            }
+            if (packetDetails[0] === "sec") {
+              keyList[keyId].isSecret = true;
             }
 
-            if (packetType === "secretKey") {
-              keyList[key.id].isSecret = true;
+            break;
+          case "fpr":
+            let fpr = packetDetails[9].toUpperCase();
+            if (keyId == null) {
+              EnigmailLog.ERROR("keyId is Null with fingerprint " + fpr);
+            } else if (fpr.substr(-keyId.length) != keyId) {
+              EnigmailLog.ERROR("Fingerprint " + fpr + " does not match key ID " + keyId);
+            } else if (!keyId in keyList) {
+              EnigmailLog.ERROR("Key ID " + keyId + " not already in list when processing fingerprint " + fpr);
+            } else {
+              keyList[keyId].fpr = fpr;
             }
             break;
-          case "userid":
-            if (!key.name) {
-              key.name = m.packets[i].userid.replace(/[\r\n]+/g, " ");
+          case "uid":
+            if (!keyList[keyId].name) {
+              // this value is escaped to fit in the
+              // colon+newline-delimited format.  should we try to
+              // unescape this?  if so, should we clean up any
+              // resulting \r or \n into spaces?
+              keyList[keyId].name = packetDetails[9];
             }
             break;
-          case "signature":
-            if (m.packets[i].signatureType === SIG_TYPE_REVOCATION) {
-              let keyId = m.packets[i].issuerKeyId.toHex().toUpperCase();
-              if (keyId in keyList) {
-                keyList[keyId].revoke = true;
-              }
-              else {
-                keyList[keyId] = {
-                  revoke: true,
-                  id: keyId
-                };
-              }
+          case "rvs":
+            keyId = packetDetails[4].toUpperCase();
+            if (keyId in keyList) {
+              keyList[keyId].revoke = true;
+            }
+            else {
+              keyList[keyId] = {
+                revoke: true,
+                id: keyId
+              };
             }
             break;
         }
